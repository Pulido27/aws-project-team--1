import logging
import json
import struct
import re
import sys
from pathlib import Path
from collections import Counter
from gen_dic import indices  # Importar diccionario

cont = 0

def obtener_tamaño_set(mi_set):
    tamaño_total = sys.getsizeof(mi_set)  # Tamaño del set en sí
    for elemento in mi_set:
        tamaño_total += sys.getsizeof(elemento)  # Tamaño de cada elemento
    return tamaño_total

def escribir_bin(buffer) :
    # Escritura en batch para minimizar accesos al disco
    for palabra, data in buffer.items():
        
        palabra_ruta = Path(f"/home/ubuntu/python_code/y/{palabra}")
        
        with palabra_ruta.open("ab") as f:
            # Escribir todo el buffer de una vez
            f.writelines(data)

    buffer.clear()
        
# Convierte la ruta en un objeto Path
ruta = Path("/home/ubuntu/python_code/pruebas")
# Buffer para escritura en batch (reduce accesos a disco)
buffers = {}

# Itera la ruta con los archivos dentro
for carpeta in ruta.iterdir():
    cont += 1
    if carpeta.is_dir():
            
        ruta_json = carpeta / "metadata.json"
        contenidoJson = ruta_json.read_text(encoding='utf-8')
        objPy = json.loads(contenidoJson)
        
        ruta_txt = carpeta / f"{carpeta.name}_djvu.txt"
        contenidoTxt = ruta_txt.read_text(encoding='utf-8')   
        
        # Estructura SET donde se guardaran las palabras para no realizar procesos extras con las palabras que se repiten
        palabrasLib = set()
        # Variable donde se ira creando cada palabra
        palabra = []
        # Variable para guardar el titulo
        titulo = objPy["title"]

        for letra in contenidoTxt:
            
            # Reviso que sea una palabra por que contiene caracteres del alfabeto ingles
            if letra.isalpha():
                palabra.append(letra)
            # Cuando lo que haya no sea una letra significa que la palabra habra acabado (Se agreggo la condicion de palabra != "" para asegurar que exista una palabra al ser agregado)
            elif palabra:
                palabra_str = "".join(palabra).lower() 
                palabrasLib.add(palabra_str)
                palabra.clear()
        
        for palabra in palabrasLib:
            # Verificar si la plabra es valida
            if len(palabra) > 3 and len(palabra) < 15:

                # Agregar a buffer de escritura
                if palabra not in buffers:
                    buffers[palabra] = []
                
                # Guardar la posicion del index
                buffers[palabra].append(struct.pack("I", indices[titulo]))

    if len(buffers) > 50000:
        escribir_bin(buffers)

# Escribir los sobrantes
escribir_bin(buffers) 
        
        
        
        
        
        # IGNORA CODIGO DE PRUEBA 
        
    #     tituloLib = objPy["title"]
    #     letraLib = tituloLib[0].lower()
    #     letraCarpeta = Path(f"/home/ubuntu/python_code/prePosCarp/{letraLib}")
    #     tituloArchi = Path(f"/home/ubuntu/python_code/prePosCarp/Titulos")
        
    #     # Crea la carpeta si no existe
    #     letraCarpeta.mkdir(exist_ok=True)
        
    #     # Crea el archivo titulo.txt sino existe
    #     tituloArchi.touch(exist_ok=True)
        
    #     # Abre el archivo donde se guardan los indices
    #     with open(tituloArchi, "a") as idxLib:
    #         posicion = idxLib.tell() # Posicion de donde empezara a escribir
    #         idxLib.write(tituloLib + "\n")
    #         print(posicion)
    
    # Este break es para que se ejecute solo de 1 libro, si quieres que lo haga con todos los libros quita el break
    